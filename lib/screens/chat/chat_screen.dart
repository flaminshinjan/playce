import 'dart:async';
import 'package:flutter/material.dart';
import 'package:playce/constants/app_theme.dart';
import 'package:playce/models/message_model.dart';
import 'package:playce/models/user_model.dart';
import 'package:playce/services/supabase_service.dart';
import 'package:playce/constants/supabase_constants.dart';
import 'package:playce/widgets/message_bubble.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:timeago/timeago.dart' as timeago;
import 'package:intl/intl.dart';

class ChatScreen extends StatefulWidget {
  final UserModel recipient;

  const ChatScreen({
    Key? key,
    required this.recipient,
  }) : super(key: key);

  @override
  State<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> with TickerProviderStateMixin {
  final _supabaseService = SupabaseService();
  final _messageController = TextEditingController();
  final _scrollController = ScrollController();
  late AnimationController _typingAnimController;
  
  List<MessageModel> _messages = [];
  bool _isLoading = true;
  bool _isSending = false;
  bool _isTyping = false;
  late String _currentUserId;
  
  RealtimeChannel? _subscription;
  Timer? _typingTimer;
  
  @override
  void initState() {
    super.initState();
    _currentUserId = _supabaseService.getCurrentUserId() ?? '';
    _loadMessages();
    _setupRealtimeSubscription();
    
    _typingAnimController = AnimationController(
      vsync: this, 
      duration: const Duration(milliseconds: 1200)
    )..repeat();
    
    _messageController.addListener(_onTypingChanged);
  }
  
  void _onTypingChanged() {
    final isCurrentlyTyping = _messageController.text.isNotEmpty;
    
    if (isCurrentlyTyping != _isTyping) {
      setState(() {
        _isTyping = isCurrentlyTyping;
      });
    }
    
    // Reset typing timer
    _typingTimer?.cancel();
    if (isCurrentlyTyping) {
      _typingTimer = Timer(const Duration(seconds: 5), () {
        if (mounted && _isTyping) {
          setState(() {
            _isTyping = false;
          });
        }
      });
    }
  }
  
  @override
  void dispose() {
    _messageController.removeListener(_onTypingChanged);
    _messageController.dispose();
    _scrollController.dispose();
    _typingAnimController.dispose();
    _subscription?.unsubscribe();
    _typingTimer?.cancel();
    super.dispose();
  }
  
  void _setupRealtimeSubscription() {
    final chatId = 'chat_${_currentUserId}_${widget.recipient.id}';
    final client = Supabase.instance.client;
    
    _subscription = client
        .channel(chatId)
        .onPostgresChanges(
          event: PostgresChangeEvent.insert,
          schema: 'public',
          table: SupabaseConstants.messagesTable,
          callback: (payload) {
            print('Received message notification');
            // Refresh messages when new messages arrive
            _loadMessages();
          },
        )
        .subscribe();
  }
  
  Future<void> _loadMessages() async {
    if (mounted) {
      setState(() {
        _isLoading = true;
      });
    }
    
    try {
      final messages = await _supabaseService.getMessages(
        _currentUserId,
        widget.recipient.id,
      );
      
      if (mounted) {
        setState(() {
          // Sort messages by creation date to ensure chronological order (oldest first)
          _messages = messages..sort((a, b) => a.createdAt.compareTo(b.createdAt));
          _isLoading = false;
        });
        
        // Mark received messages as read
        _markMessagesAsRead();
        
        // Scroll to bottom after a short delay to ensure messages are rendered
        if (_messages.isNotEmpty) {
          Future.delayed(const Duration(milliseconds: 100), () {
            _scrollToBottom();
          });
        }
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading messages: ${e.toString()}'),
            backgroundColor: AppColors.error,
          ),
        );
      }
    }
  }
  
  Future<void> _markMessagesAsRead() async {
    try {
      await _supabaseService.markMessagesAsRead(
        widget.recipient.id,
        _currentUserId,
      );
    } catch (e) {
      // Just log the error, don't show to user
      print('Error marking messages as read: $e');
    }
  }
  
  Future<void> _sendMessage() async {
    final content = _messageController.text.trim();
    if (content.isEmpty) {
      return;
    }
    
    setState(() {
      _isSending = true;
      _isTyping = false;
    });
    
    try {
      final newMessage = MessageModel(
        id: '', // Will be generated by sendMessage method or database
        senderId: _currentUserId,
        receiverId: widget.recipient.id,
        content: content,
        isRead: false,
        createdAt: DateTime.now(),
      );
      
      // Clear the text field immediately
      _messageController.clear();
      
      // Add message optimistically to the end of the list (newest messages at the bottom)
      if (mounted) {
        setState(() {
          _messages = [..._messages, newMessage];
        });
        
        // Scroll to the bottom immediately to show the new message
        _scrollToBottom();
      }
      
      print('Sending message to ${widget.recipient.username}: ${content.substring(0, content.length > 20 ? 20 : content.length)}...');
      await _supabaseService.sendMessage(newMessage);
      print('Message sent successfully');
      
      if (mounted) {
        setState(() {
          _isSending = false;
        });
      }
      
      // Optionally refresh messages after a short delay to ensure server sync
      // This is needed to get the correct ID and timestamp from the server
      Future.delayed(const Duration(milliseconds: 500), () {
        if (mounted) {
          _loadMessages();
        }
      });
    } catch (e) {
      print('Error sending message: $e');
      if (mounted) {
        // Remove the optimistically added message
        setState(() {
          _isSending = false;
          _messages = _messages.where((m) => m.id.isNotEmpty).toList();
        });
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error sending message: ${e.toString()}'),
            backgroundColor: AppColors.error,
            action: SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: () {
                _messageController.text = content;
                _sendMessage();
              },
            ),
          ),
        );
      }
    }
  }
  
  void _scrollToBottom() {
    if (_scrollController.hasClients) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final recipientName = widget.recipient.username ?? 'User';
    
    return Scaffold(
      backgroundColor: AppColors.background,
      appBar: AppBar(
        elevation: 1,
        titleSpacing: 0,
        title: Row(
          children: [
            Hero(
              tag: 'avatar_${widget.recipient.id}',
              child: CircleAvatar(
                radius: 18,
                backgroundColor: AppColors.primaryVariant,
                backgroundImage: widget.recipient.avatarUrl != null
                    ? NetworkImage(widget.recipient.avatarUrl!)
                    : null,
                child: widget.recipient.avatarUrl == null
                    ? Text(
                        recipientName.substring(0, 1).toUpperCase(),
                        style: const TextStyle(
                          fontWeight: FontWeight.bold,
                          color: AppColors.buttonText,
                        ),
                      )
                    : null,
              ),
            ),
            const SizedBox(width: 10),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    recipientName,
                    style: AppTextStyles.headline3.copyWith(fontSize: 16),
                    overflow: TextOverflow.ellipsis,
                  ),
                  Text(
                    _isTyping ? 'typing...' : 'online',
                    style: AppTextStyles.caption.copyWith(
                      color: _isTyping ? AppColors.primary : AppColors.success,
                      fontSize: 11,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            tooltip: 'Refresh messages',
            onPressed: _loadMessages,
          ),
          IconButton(
            icon: const Icon(Icons.more_vert),
            tooltip: 'More options',
            onPressed: () {
              showModalBottomSheet(
                context: context,
                backgroundColor: AppColors.surface,
                builder: (context) => _buildOptionsSheet(),
              );
            },
          ),
        ],
      ),
      body: SafeArea(
        child: Column(
          children: [
            // Messages list
            Expanded(
              child: _isLoading
                  ? const Center(
                      child: CircularProgressIndicator(
                        valueColor: AlwaysStoppedAnimation<Color>(AppColors.primary),
                      ),
                    )
                  : _messages.isEmpty
                      ? _buildEmptyState()
                      : _buildMessagesList(),
            ),
            
            // Typing indicator
            if (_isSending)
              Container(
                alignment: Alignment.centerLeft,
                padding: const EdgeInsets.only(left: 16, top: 8),
                child: const Text(
                  'Sending...',
                  style: TextStyle(
                    color: AppColors.textSecondary,
                    fontStyle: FontStyle.italic,
                    fontSize: 12,
                  ),
                ),
              ),
              
            // Message input
            _buildMessageInput(),
          ],
        ),
      ),
    );
  }

  Widget _buildOptionsSheet() {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 20),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          ListTile(
            leading: const Icon(Icons.delete_outline, color: AppColors.textSecondary),
            title: const Text('Clear chat history'),
            onTap: () {
              Navigator.pop(context);
              // TODO: Implement clear chat functionality
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Coming soon!')),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.block, color: AppColors.error),
            title: const Text('Block user'),
            onTap: () {
              Navigator.pop(context);
              // TODO: Implement block user functionality
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Coming soon!')),
              );
            },
          ),
        ],
      ),
    );
  }
  
  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: AppColors.surface,
              shape: BoxShape.circle,
            ),
            child: const Icon(
              Icons.chat_bubble_outline,
              size: 64,
              color: AppColors.primary,
            ),
          ),
          const SizedBox(height: 24),
          Text(
            'No messages yet',
            style: AppTextStyles.headline3,
          ),
          const SizedBox(height: 12),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 32),
            child: Text(
              'Say hi to ${widget.recipient.username ?? "User"}!',
              style: AppTextStyles.bodyText2.copyWith(color: AppColors.textSecondary),
              textAlign: TextAlign.center,
            ),
          ),
          const SizedBox(height: 32),
          ElevatedButton(
            onPressed: () {
              _messageController.text = 'Hi there! 👋';
              _sendMessage();
            },
            style: ElevatedButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(20),
              ),
            ),
            child: const Text('Start conversation'),
          ),
        ],
      ),
    );
  }
  
  Widget _buildMessagesList() {
    return ListView.builder(
      controller: _scrollController,
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 16),
      itemCount: _messages.length,
      itemBuilder: (context, index) {
        final message = _messages[index];
        final isSentByMe = message.senderId == _currentUserId;
        
        // Check if we need to show date header
        final showDateHeader = index == 0 || 
            !_isSameDay(_messages[index].createdAt, _messages[index - 1].createdAt);
            
        // Check if we should group messages
        final isFirstInGroup = index == 0 || 
            _messages[index - 1].senderId != message.senderId ||
            _messages[index].createdAt.difference(_messages[index - 1].createdAt).inMinutes > 5;
            
        final isLastInGroup = index == _messages.length - 1 || 
            _messages[index + 1].senderId != message.senderId ||
            _messages[index + 1].createdAt.difference(message.createdAt).inMinutes > 5;
        
        return Column(
          children: [
            if (showDateHeader) _buildDateHeader(message.createdAt),
            MessageBubble(
              message: message,
              isSentByMe: isSentByMe,
              isFirstInGroup: isFirstInGroup,
              isLastInGroup: isLastInGroup,
              showAvatar: !isSentByMe && isLastInGroup,
              senderAvatarUrl: widget.recipient.avatarUrl,
              senderName: widget.recipient.username ?? 'User',
            ),
          ],
        );
      },
    );
  }
  
  Widget _buildDateHeader(DateTime date) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 16),
      child: Center(
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
          decoration: BoxDecoration(
            color: AppColors.surface,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Text(
            _formatHeaderDate(date),
            style: AppTextStyles.caption,
          ),
        ),
      ),
    );
  }
  
  String _formatHeaderDate(DateTime date) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = today.subtract(const Duration(days: 1));
    final messageDate = DateTime(date.year, date.month, date.day);
    
    if (messageDate == today) {
      return 'Today';
    } else if (messageDate == yesterday) {
      return 'Yesterday';
    } else if (now.difference(messageDate).inDays < 7) {
      return DateFormat('EEEE').format(date); // Day name
    } else {
      return DateFormat('MMM d, y').format(date); // Month Day, Year
    }
  }
  
  bool _isSameDay(DateTime date1, DateTime date2) {
    return date1.year == date2.year && 
           date1.month == date2.month && 
           date1.day == date2.day;
  }
  
  Widget _buildMessageInput() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: AppColors.surface,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            offset: const Offset(0, -1),
            blurRadius: 4,
          ),
        ],
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          // Attachment button
          IconButton(
            icon: const Icon(Icons.add_circle_outline, color: AppColors.textSecondary),
            onPressed: () {
              // TODO: Implement attachment functionality
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Attachment feature coming soon!')),
              );
            },
            visualDensity: VisualDensity.compact,
            splashRadius: 24,
            tooltip: 'Add attachment',
          ),
          
          // Text field
          Expanded(
            child: Container(
              decoration: BoxDecoration(
                color: AppColors.cardBackground,
                borderRadius: BorderRadius.circular(24),
              ),
              child: TextField(
                controller: _messageController,
                decoration: InputDecoration(
                  hintText: 'Type a message...',
                  border: InputBorder.none,
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                  hintStyle: TextStyle(color: AppColors.textHint),
                  suffixIcon: IconButton(
                    icon: const Icon(Icons.emoji_emotions_outlined, color: AppColors.textSecondary),
                    onPressed: () {
                      // TODO: Implement emoji picker
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text('Emoji picker coming soon!')),
                      );
                    },
                    visualDensity: VisualDensity.compact,
                    splashRadius: 24,
                    tooltip: 'Add emoji',
                  ),
                ),
                maxLines: 4,
                minLines: 1,
                textCapitalization: TextCapitalization.sentences,
                style: AppTextStyles.bodyText1,
                onSubmitted: (_) => _sendMessage(),
              ),
            ),
          ),
          
          // Send button
          Padding(
            padding: const EdgeInsets.only(left: 8),
            child: FloatingActionButton(
              onPressed: _isSending ? null : _sendMessage,
              mini: true,
              backgroundColor: AppColors.primary,
              foregroundColor: AppColors.buttonText,
              elevation: 1,
              highlightElevation: 2,
              tooltip: 'Send message',
              child: _isSending
                  ? const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        color: AppColors.buttonText,
                        strokeWidth: 2,
                      ),
                    )
                  : const Icon(Icons.send),
            ),
          ),
        ],
      ),
    );
  }
} 